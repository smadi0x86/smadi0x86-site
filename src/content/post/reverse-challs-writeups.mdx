---
title: "Reverse Engineering Fun"
description: "A collection of reverse engineering challenges and their solutions."
publishDate: "2025-08-06T00:00:00Z"
tags: ["reverse-engineering", "writeups", "security"]
draft: false
---

# UnCrackable

## Challenge Overview

When first examining the binary with Detect It Easy (DIE), the application didnâ€™t immediately appear to be a .NET executable.

but when i checked its imports i found mscoree.dll which is a crucial file for the .NET Framework, specifically acting as the runtime execution engine for managed code.

<img src="/images/uncrackable/uncrackable-1.png" alt="" />

From here I knew what I'll exactly do, ill run the binary for now and then instantly try to unpack it with a themida .net unpacker and even if it didnt reconstruct imports i can do it manually...

<img src="/images/uncrackable/uncrackable-2.png" alt="" />

When running the binary at first it gives you a string that can be decrypted to:

<img src="/images/uncrackable/uncrackable-3.png" alt="" />

What first comes to mind is to find a similar string that when decrypted by the program will give the flag...

## Unpacking the Binary

I loaded the binary in x32dbg and it was a pain to trace and wasted me a good amount of time trying to bypass `CheckRemoteDebuggerPresent()` anti-debug (scylla-hide didn't work for some reason, probably a 32 bit issue), so i decided to look for [Themida-Unpacker-for-.NET](https://github.com/cg10036/Themida-Unpacker-for-.NET).

Its worth noting that i wasted time breaking on `GetModuleHandleA`, `GetProcAddress`... imports as they are used to resolve dynamic apis so i can dump the unpacked binary at runtime

```c
1. GetModuleHandleA("kernel32.dll")  // Getting base APIs

2. GetProcAddress() for VirtualProtect()  // Preparing to unpack

3. GetModuleHandleA("mscoree.dll")   // .NET runtime

4. Memory writes to unpack the .NET assembly

5. GetModuleHandleA("advapi32.dll")  // For CryptoAPI
```

but the issue was for some reason bypassing anti debug wasn't successful, this is just a fail i would love to mention...

<img src="/images/uncrackable/uncrackable-4.png" alt="" />

This unpacker outputs all dumped dlls (imports) resolved and reconstruct the PE accordingly `UNCRACKABLE_protected_exe_PID8338_UNCRACKABLE_protected.exe_400000_x86.exe`

Now if i try to run this new dumped binary to detect it easy, it will instantly identify it as a .net binary

<img src="/images/uncrackable/uncrackable-5.png" alt="" />

## Deobfuscating the Binary

Now if we load it in a .net decompiler, we will see these unreadable garbage which is caused by agile .net obfuscator, so we need to deobfuscate it.

<img src="/images/uncrackable/uncrackable-6.png" alt="" />

I used [AgileDotNetSlayer](https://github.com/SychicBoy/AgileDotNetSlayer) to deobfuscate the agile obfuscated strings

After the binary is deobfuscated from the agile obfuscation, we can take a closer look into what is happening

<img src="/images/uncrackable/uncrackable-7.png" alt="" />

## Analyzing the Code

At this point the challenge is almost solved, so lets analyze the code:

```csharp
public class Form1 : Form
{
    private TextBox $\u$200b$\u$000a;
    private Label $\u$200b$\u$000d;
    private Button $\u$200b ;


    private void $\u$200b$\u$1680()

    {
        // ... UI initialization code ...

        // same string that gave us "seriously ?!!!"

        $\u$200b$\u$000a.Text = "Vf7jRjdvebvLtzL2V1DY57xNAdFb1fwQEssdXJI8fjk4YRcUinl7qnh8yhm7zV6L";

        // Label showing "Flag:"

        $\u$200b$\u$000d.Text = "Flag:";

        // Button labeled "Decrypt me"

        $\u$200b .Text = "Decrypt me";

        $\u$200b .Click += $\u$200b$\u$00a0;
    }
}
```

The button click handler contained what appeared to be the main decryption logic

```csharp
private void $\u$200b$\u$00a0(object sender, EventArgs e)

{
    string keyString = "f9QzA7wL1kP6rMbD8YcN2zWvJ4XhVsTy";

    string ivString = "A1b2C3d4E5f6G7h8";

    byte[] bytes = AesPInvokeDecryptor.Decrypt("RBpjBfdNNXfv24T2hi8Cqw==", keyString, ivString);

    MessageBox.Show(Encoding.UTF8.GetString(bytes));
}
```

I decrypted this hardcoded string:

```csharp
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

encrypted_b64 = "RBpjBfdNNXfv24T2hi8Cqw=="
key = "f9QzA7wL1kP6rMbD8YcN2zWvJ4XhVsTy".encode('utf-8')
iv = "A1b2C3d4E5f6G7h8".encode('utf-8')

encrypted = base64.b64decode(encrypted_b64)

cipher = AES.new(key, AES.MODE_CBC, iv)

decrypted = unpad(cipher.decrypt(encrypted), AES.block_size)

print(decrypted.decode('utf-8'))

# Output: "seriously ?!!!"
```

I didn't expect that, but then i realized what about the text string that appeared when we executed the binary... so i tried:

```csharp
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

# text box value
encrypted_b64 = "Vf7jRjdvebvLtzL2V1DY57xNAdFb1fwQEssdXJI8fjk4YRcUinl7qnh8yhm7zV6L"
key = "f9QzA7wL1kP6rMbD8YcN2zWvJ4XhVsTy".encode('utf-8')
iv = "A1b2C3d4E5f6G7h8".encode('utf-8')

encrypted = base64.b64decode(encrypted_b64)

cipher = AES.new(key, AES.MODE_CBC, iv)

decrypted = unpad(cipher.decrypt(encrypted), AES.block_size)

flag = decrypted.decode('utf-8')

print(f"Flag: {flag}")

# Output: Flag: NCSC{f4d6fc5933efbc7bbf04e948546098cb}
```

That worked! actual flag was in the 64 character string in the text box! Using the same AES key and IV from the button handler.
